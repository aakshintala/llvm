//===-- TGSIMCInstPrinter.cpp - Convert TGSI MCInst to assembly syntax ----===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This class prints an TGSI MCInst to a .s file.
//
//===----------------------------------------------------------------------===//

#include "MCTargetDesc/TGSIMCTargetDesc.h"
#include "llvm/MC/MCExpr.h"
#include "llvm/MC/MCInst.h"
#include "llvm/MC/MCInstPrinter.h"
#include "llvm/MC/MCInstrInfo.h"
#include "llvm/MC/MCRegisterInfo.h"
#include "llvm/Support/raw_ostream.h"

using namespace llvm;

namespace {
   class TGSIMCInstPrinter : public MCInstPrinter {
   public:
      TGSIMCInstPrinter(const MCAsmInfo &mai, const MCInstrInfo &mii,
                        const MCRegisterInfo &mri)
         : MCInstPrinter(mai, mii, mri) {}

      virtual void printInst(const MCInst *mi, raw_ostream &os,
                             StringRef annot, const MCSubtargetInfo &STI);
      virtual void printRegName(raw_ostream &os, unsigned reg) const;

      // Autogenerated by tblgen.
      void printInstruction(const MCInst *MI, raw_ostream &O);
      static const char *getInstructionName(unsigned Opcode);
      static const char *getRegisterName(unsigned RegNo);

      void printOperand(const MCInst *MI, unsigned OpNo, raw_ostream &O);
   private:
      bool requiresSwizzleSuffix(const MCInst *mi, unsigned op_idx, bool isImm);
   };
}

#include "TGSIGenAsmWriter.inc"

void TGSIMCInstPrinter::printInst(const MCInst *mi, raw_ostream &os,
                                  StringRef annot, const MCSubtargetInfo &STI) {
   printInstruction(mi, os);
   printAnnotation(os, annot);
}

void TGSIMCInstPrinter::printRegName(raw_ostream &os, unsigned reg) const {
   os << getRegisterName(reg);
}

bool TGSIMCInstPrinter::requiresSwizzleSuffix(const MCInst *mi, unsigned op_idx,
                                              bool isImm)
{
   const char *name = MII.getName(mi->getOpcode());

   if ((name[0] == 'S' && name[1] == 'T' && op_idx == 0) ||
       (name[0] == 'L' && name[1] == 'D' && op_idx == 1))
         return !isImm;

   return op_idx >= 1;
}

void TGSIMCInstPrinter::printOperand(const MCInst *mi, unsigned op_idx,
                                     raw_ostream &os) {
   const MCOperand &op = mi->getOperand(op_idx);

   if (op.isReg()) {
      if (requiresSwizzleSuffix(mi, op_idx, false)) {
         MCSuperRegIterator Supers(op.getReg(), &MRI);
         if (Supers.isValid()) {
            /* Subreg source operand, print superreg name +
               subreg matching swizzle info */
            const char *postfix[] = {
               NULL,
               ".wwww",
               ".xxxx",
               ".yyyy",
               ".zzzz"
            };
            os << getRegisterName(*Supers)
               << postfix[MRI.getSubRegIndex(*Supers, op.getReg())];
            return;
         }
      }
      os << getRegisterName(op.getReg());
   } else if (op.isImm()) {
      os << "IMM[" << op.getImm() << "]";
      if (requiresSwizzleSuffix(mi, op_idx, true))
         os << ".xxxx";
   } else if (op.isExpr())
      os << *op.getExpr();
   else
      assert(0);
}

MCInstPrinter *llvm::createTGSIMCInstPrinter(const Triple &tt,
                                             unsigned SyntaxVariant,
                                             const MCAsmInfo &mai,
                                             const MCInstrInfo &mii,
                                             const MCRegisterInfo &mri) {
   return new TGSIMCInstPrinter(mai, mii, mri);
}
